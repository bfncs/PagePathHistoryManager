<?php

/**
 * Page Path History Manager Module
 *
 * Manage PagePathHistory entries for any page on the Page Edit form.
 *
 * @version 0.0.1
 * @license MIT
 * @author Marc Löhe <marc@marcloehe.de>
 * @copyright Copyright (c) 2015, Marc Löhe
 */
class PagePathHistoryManager extends Process implements Module
{
    /**
     * @var Page Save currently edited page
     */
    protected $editPage;

    /**
     * @var Page Admin page where the module process is registered
     */
    protected $processPage;

    /**
     * @var string PagePathHistory database table name
     */
    protected $dbTableName;

    /**
     * @var string Url of ProcessPageEdit page
     */
    protected $editUrl;

    /**
     * Build meta information for module integration.
     *
     * @return array Module information
     */
    public static function getModuleInfo()
    {
        return array(
            'title' => __('Page Path History Manager'),
            'version' => 100,
            'summary' => __('Manage PagePathHistory entries for any page on the Page Edit form.'),
            'author' => 'Marc Löhe',
            'requires' => array('ProcessWire>=2.4.0', 'PHP>=5.4.0'),
            'singular' => true,
            'autoload' => 'process=ProcessPageEdit',
            'permission' => 'page-edit',
        );
    }

    /**
     * Module initialization
     *
     * Determine correct PagePathHistory module and register hooks.
     *
     * @return void
     */
    public function init()
    {
        parent::init();

        // Determine page path history module and db table
        $active = false;
        $implementingModules = array(
            'PagePathHistoryLanguage',
            'PagePathHistory',
        );
        foreach ($implementingModules as $moduleName) {
            if ($this->modules->isInstalled($moduleName)) {
                $active = true;
                $this->dbTableName = constant($moduleName . '::dbTableName');
                break;
            }
        }

        // Do nothing if PagePathHistory is not active
        if (!$active) {
            return;
        }

        // Add hooks and setup needed variables
        $this->editUrl = $this->config->urls->admin . 'page/edit/';
        $processPageName = strtolower(__CLASS__);
        $this->processPage = $this->pages->get("name={$processPageName},has_parent={$this->config->adminRootPageID},include=all");
        $this->addHookBefore('ProcessPageEdit::execute', $this, 'hookBeforeProcessPageEditExecute');
        $this->addHookAfter('ProcessPageEdit::buildFormSettings', $this, 'hookAfterProcessPageEditBuildFormSettings');
    }

    /**
     * Compare two associative arrays by length of the value for key 'path'.
     *
     * Used as callback to sort an array of arrays by descending string length
     * with usort().
     * Caution: Not multibyte sensitive because not needed for Processwire paths!
     * No parameter validation for maximum performance.
     *
     * @param array|string $a First array to compare.
     * @param array|string $b Second array to compare.
     * @return int Comparison result:
     * >0 if $a is longer, 0 if $a und $b are equal, <0 if $a is shorter
     */
    protected static function compareStringsByLength($a, $b)
    {
        return strlen($b['path']) - strlen($a['path']);
    }

    /**
     * Add the custom css to be loaded for ProcessPageEdit module.
     *
     * @param HookEvent $event
     * @return void
     */
    public function hookBeforeProcessPageEditExecute(HookEvent $event)
    {
        $class = $this->className();
        $info = $this->wire('modules')->getModuleInfo($this, array('verbose' => false));
        $version = (int) isset($info['version']) ? $info['version'] : 0;

        $this->config->styles->add($this->config->urls->{$class} . "ProcessPageEdit.css?v=$version");
    }

    /**
     * Add the path history inputfield to the settings tab on the Page Edit form.
     *
     * @param HookEvent $event
     * @return void
     */
    public function hookAfterProcessPageEditBuildFormSettings(HookEvent $event)
    {
        /* @var InputfieldWrapper $wrapper */
        $wrapper = $event->return;
        /* @var ProcessPageEdit $process */
        $process = $event->object;
        $this->editPage = $process->getPage();

        $field = $this->buildFormPathHistory();
        $wrapper->insertAfter($field, $wrapper->children()->first());
    }

    public function ___execute()
    {
        $out = '';

        $isPost = 0 < strlen($this->input->post('id'));
        $pageId = (int) $this->input->{$isPost ? 'post' : 'get'}('id');

        if (!$pageId) {
            throw new WireException('Please supply a valid page id.');
        }

        $page = $this->pages->get($pageId);
        if (!$page || $page instanceof NullPage) {
            throw new WireException('No page found for given path.');
        }

        $path = $this->sanitizer->url($this->input->{$isPost ? 'post' : 'get'}('path'));
        $redirectUrl = "{$this->processPage->path}?id={$pageId}&path={$path}";

        if ($isPost) {
            // Check whether path is valid
            if (!$path) {
                $msg = $this->_('Please enter a valid path.'); // Message: invalid path given
                $this->message($msg, Notice::warning);
                $this->session->redirect($redirectUrl);
            }

            // Make sure that path starts with but doesn't end with slash
            $path = '/' . trim($path, '/');

            // Prepare path selector value
            $pathSelector = $this->sanitizer->selectorValue($path);

            // Check whether path is already used as regular path for another page
            if (0 < $this->pages->count("path={$pathSelector},include=all")) {
                $msg = $this->_('The requested path is already in use by another page.'); // Message: path already in use
                $this->message($msg, Notice::warning);
                $this->session->redirect($redirectUrl);
            }

            // Check whether path is already used as history path for another page
            $existingHistoryPage = $this->fetchPageByHistoryPath($pathSelector);
            if ($existingHistoryPage && !($existingHistoryPage instanceof NullPage)) {
                $msg = $this->_('The requested path is already in use as history path of another page.'); // Message: path already in use as history path
                $this->message($msg, Notice::warning);
                $this->session->redirect($redirectUrl);
            }

            // Try to add path to the database
            $success = $this->addHistoryPath($path, $pageId);

            // Prepare message
            $msg = $success ?
                $this->_('Successfully added history path "%1$s" for page "%2$s".') : // Message: history path was added
                $this->_('Unable to add history path "%1$s" for page "%2$s".'); // Message: history path could not be added
            $msgFlags = Notice::log;
            if (!$success) {
                $msgFlags |= Notice::warning;
            }
            $this->message(sprintf($msg, $path, $page->path), $msgFlags);

            // Redirect to page edit form
            $pageEditUrl = $this->editUrl . "?id={$page->id}";
            $this->session->redirect($pageEditUrl);
        }

        $form = $this->buildFormCreateHistoryPath($page, $path);
        $out .= $form->render();

        return $out;
    }

    /**
     * Handle history path deletion requests.
     *
     * @return string Page output
     * @throws WireException
     */
    public function ___executeDelete()
    {
        $out = '';
        $isPost = 0 < strlen($this->input->post('path'));
        $path = $this->input->{$isPost ? 'post' : 'get'}('path');
        if (!$path) {
            throw new WireException('Please supply a valid path.');
        }

        $page = $this->fetchPageByHistoryPath($path);
        if (!$page || $page instanceof NullPage) {
            throw new WireException('No page found for given path.');
        }

        if ($isPost) {
            // Redirect back if confirmation was not checked
            if (!$this->input->post('confirmed')) {
                $msg = $this->_('Please confirm the deletion of path "%s".'); // Message: deletion not confirmed
                $this->message(sprintf($msg, $path), Notice::warning);
                $this->session->redirect("{$this->processPage->path}delete?path={$path}");
            }

            // Try to delete history path from database
            $success = $this->deleteHistoryPath($path);

            // Prepare message
            $msg = $success ?
                $this->_('Successfully deleted history path "%s".') : // Message: history path was deleted
                $this->_('Unable to delete history path "%s".'); // Message: history path could not be deleted
            $msgFlags = Notice::log;
            if (!$success) {
                $msgFlags |= Notice::warning;
            }
            $this->message(sprintf($msg, $path), $msgFlags);

            // Redirect to page edit form
            $pageEditUrl = $this->editUrl . "?id={$page->id}";
            $this->session->redirect($pageEditUrl);
        }

        $form = $this->buildFormDeleteConfirmation($path, $page);
        $out .= $form->render();

        return $out;
    }

    public function install()
    {
        parent::___install();

        /* Create manager page */
        if (!count($this->pages->find('name=' . __CLASS__))) {
            $p = new Page();
            $p->template = $this->templates->get('admin');
            $p->title = 'Page Path History Manager';
            $p->name = __CLASS__;
            $p->parent = $this->pages->get(3); // Create as children of /admin/pages
            $p->status = Page::statusHidden | Page::statusSystem; // Hide in menu and prevent deletion
            $p->process = $this;
            $p->save();
        }
    }

    public function uninstall()
    {
        parent::___uninstall();

        /* Delete manager page */
        $p = $this->pages->get('name=' . __CLASS__);
        if ($p && !($p instanceof NullPage)) {
            $p->status = Page::statusSystemOverride; // Allow status override
            $p->status = 0; // Remove system status to enable deletion
            $this->pages->delete($p);
        }
    }

    /**
     * Build the path history inputfield to be attached to the settings tab
     * on the Page Edit form.
     *
     * @return InputfieldMarkup Path history inputfield
     */
    protected function buildFormPathHistory()
    {
        // Get all needed path history data for current page
        $currentPagePaths = $this->fetchHistoryPathsByPage($this->editPage);

        // Get all needed path history data for parent pages
        $parentPagePaths = array();
        $currentPageParents = $this->editPage->parents->reverse();
        foreach ($currentPageParents as $parentPage) {
            $parentPagePaths = array_merge($parentPagePaths, $this->fetchHistoryPathsByPage($parentPage));
        }

        // Prepare inputfield output
        /* @var InputfieldMarkup $field */
        $field = $this->modules->get('InputfieldMarkup');
        $field->label = $this->_('Page path history'); // Page Path History Manager field label
        $out = '';

        $pathTableHeaderRow = array(
            $this->_('Path'), // Page Path History Manager table header: Path
            $this->_('Page'), // Page Path History Manager table header: Page
            $this->_('Created'), // Page Path History Manager table header: Created
            $this->_('Actions'), // Page Path History Manager table header: Actions
        );
        $pagePathGroups = array(
            'currentPagePaths' => $this->_('Former URLs of current page'), // Page Path History Manager table heading: current page
            'parentPagePaths' => $this->_('Former URLs of parent pages'), // Page Path History Manager table heading: parent pages
        );
        $labelPathDelete = $this->_('delete'); // Page Path History Manager table item: delete button label

        $pageEmpty = empty($currentPagePaths) && empty($parentPagePaths);
        if ($pageEmpty) {
            // Build message if no history paths were found
            $msg = $this->_('There are no former URLs registered for this page.'); // Page Path History Manager empty notice
            $out .= '<div class="pph-man-notice-empty"><p class="notes">' . $msg . '</p></div>';
        } else {
            // Build current and parent paths tables
            foreach ($pagePathGroups as $groupName => $groupLabel) {
                $out .= '<div class="pph-man-table-header">' . $groupLabel . '</div>';
                if (empty(${$groupName})) {
                    $msg = $this->_('There are no former URLs registered in this category.'); // Page Path History Manager: empty group notice
                    $out .= '<div class="pph-man-notice-groupempty"><p class="notes">' .
                        $msg . '</p></div>';
                } else {
                    // Prepare data for building the path history table of this group
                    $content = array();
                    foreach (${$groupName} as $entry) {
                        $path = $entry['path'];
                        $pageId = $entry['pageId'];
                        $created = $entry['created'];
                        $contentRow = array();

                        // Add path column
                        $contentRow[] = '<a class="pph-man-item-delete" href="' . $path . '">' .
                            $path . '</a>';

                        // Add page column only if not current page paths
                        if ('currentPagePaths' !== $groupName) {
                            $page = $this->pages->get($pageId);
                            $pageEditUrl = $this->editUrl . "?id={$pageId}";
                            $contentRow[] = '<a class="pph-man-item-page" href="' . $pageEditUrl . '">' .
                                $page->path . '</a>';
                        }

                        // Add created column
                        $contentRow[] = $created;

                        // Add actions column
                        $pathDeleteUrl = "{$this->processPage->path}delete?path={$path}";
                        $contentRow[] = '<div class="actions"><a class="pph-man-item-delete" href="' .
                            $pathDeleteUrl . '">' . $labelPathDelete . '</a></div>';

                        $content[] = $contentRow;
                    }

                    // Remove page header row for current page paths
                    $headerRow = $pathTableHeaderRow;
                    if ('currentPagePaths' === $groupName) {
                        unset($headerRow[0]);
                    }

                    // Build table from prepared data
                    $table = $this->buildPathsTable($headerRow, $content);

                    // Render table data
                    $out .= $table->render();
                }
            }
        }

        // Add history path creation button
        $createUrl = $this->processPage->path . "?id={$this->editPage->id}";
        $createLabel = $this->_('Create new fallback path'); // Page Path History Manager: Create button label
        $out .= '<div class="actions"><a class="pph-man-btn-create" href="' .
            $createUrl . '">' . $createLabel . '</a></div>';

        // Fill inputfield with content and return it
        $field->value = $out;
        return $field;
    }

    /**
     * Build the path creation form for a given page (and optional path).
     *
     * @param $page The page for which the path should be created.
     * @param string $path A path to prefill the form with. Optional.
     * @return InputfieldForm The form to create a path.
     */
    protected function buildFormCreateHistoryPath($page, $path = '')
    {
        /* @var InputfieldForm $form */
        $form = $this->modules->get('InputfieldForm');
        $form->attr('method', 'post');
        $form->description = sprintf($this->_('Create history path for page "%s"'), $page->path); // Path creation form headline

        /* @var InputfieldHidden $field */
        $field = $this->modules->get('InputfieldHidden');
        $field->attr('name', 'id');
        $field->attr('value', $page->id);
        $form->append($field);

        /* @var InputfieldHidden $field */
        $field = $this->modules->get('InputfieldText');
        $field->attr('name', 'path');
        $field->attr('value', $path);
        $field->label = $this->_('Path');
        $field->description = $this->_('Please enter the URL you want to add for this page.');
        $form->append($field);

        /* @var InputfieldSubmit $field */
        $field = $this->modules->get('InputfieldSubmit');
        $form->append($field);

        return $form;
    }

    /**
     * Build the path deletion confirmation form for a given page and path.
     *
     * @param $path The path to be deleted.
     * @param $page The page for which the path should be deleted.
     * @return InputfieldForm The form to confirm the deletion.
     */
    protected function buildFormDeleteConfirmation($path, $page)
    {
        /* @var InputfieldForm $form */
        $form = $this->modules->get('InputfieldForm');
        $form->attr('action', 'delete');
        $form->attr('method', 'post');
        $form->description = sprintf($this->_('Delete history path "%1$s" for page "%2$s"'), $path, $page->path); // Path deletion confirmation form headline

        /* @var InputfieldHidden $field */
        $field = $this->modules->get('InputfieldHidden');
        $field->attr('name', 'path');
        $field->attr('value', $path);
        $form->append($field);

        /* @var InputfieldCheckbox $field */
        $field = $this->modules->get('InputfieldCheckbox');
        $field->attr('name', 'confirmed');
        $field->attr('value', 'confirmed');
        $field->label = $this->_('Are you sure?'); // Checkbox label to confirm they want to delete a given history path
        $field->description = $this->_('Please confirm that you understand the above by clicking the checkbox below.'); // Checkbox description to confirm they want to delete a given history path
        $form->append($field);

        /* @var InputfieldSubmit $field */
        $field = $this->modules->get('InputfieldSubmit');
        $form->append($field);

        return $form;
    }

    /**
     * Get a page by its history page path.
     *
     * @param string $path History URL to lookup.
     * @return NullPage|Page Page if path exists, NullPage if not.
     */
    protected function fetchPageByHistoryPath($path = '')
    {
        $page = new NullPage();
        $path = $this->sanitizer->url($path); // Sanitize path
        if (empty($path)) {
            return $page;
        }

        /* @var WireDatabasePDO $db */
        $db = $this->wire('database');
        $query = $db->prepare("SELECT pages_id FROM {$this->dbTableName} WHERE path=:path LIMIT 1");
        $query->bindValue('path', $path);
        $query->execute();
        if (0 < $query->rowCount()) {
            $pageId = (int) $query->fetchColumn();
            $page = $this->pages->get($pageId);
        }
        $query->closeCursor();

        return $page;
    }

    /**
     * Fetch all paths for a given page from the database.
     *
     * @param Page|int $page Lookup page object or id
     * @param bool $sort True if paths should be sorted by length
     * @return array Saved history paths for that page
     */
    protected function fetchHistoryPathsByPage($page, $sort = true)
    {
        if (is_object($page) && $page instanceof Page) {
            $page = $page->id;
        } else {
            $page = intval($page, 10);
        }

        /* @var WireDatabasePDO $db */
        $db = $this->wire('database');
        $query = $db->prepare("SELECT path, created FROM {$this->dbTableName} WHERE pages_id=:id");
        $query->bindValue(':id', $page);
        $query->execute();

        $paths = array();
        if (0 < $query->rowCount()) {
            while ($path = $query->fetch(PDO::FETCH_ASSOC)) {
                $path['pageId'] = $page;
                $paths[] = $path;
            }
        }
        $query->closeCursor();

        if ($sort) {
            usort($paths, 'self::compareStringsByLength');
        }

        return $paths;
    }

    /**
     * Add a history path to the database.
     *
     * @param string $path Path to be added
     * @param Page|int $page Page object or id to be associated to path
     * @return bool True if addition was successful, false if not
     */
    protected function addHistoryPath($path, $page) {
        $success = false;

        if (is_object($page) && $page instanceof Page) {
            $page = $page->id;
        } else {
            $page = intval($page, 10);
        }

        /* @var WireDatabasePDO $db */
        $db = $this->wire('database');
        $query = $db->prepare("INSERT INTO {$this->dbTableName} SET path=:path, pages_id=:pages_id, created=NOW()");
        $query->bindValue(":path", $path);
        $query->bindValue(":pages_id", $page, PDO::PARAM_INT);
        $query->execute();
        if (0 < $query->rowCount()) {
            $success = true;
        }
        $query->closeCursor();

        return $success;
    }

    /**
     * Delete a history path from the database.
     *
     * @param string $path Path to be deleted
     * @return bool True if deletion was successful, false if not
     */
    protected function deleteHistoryPath($path)
    {
        $success = false;

        /* @var WireDatabasePDO $db */
        $db = $this->wire('database');
        $query = $db->prepare("DELETE FROM {$this->dbTableName} WHERE path=:path LIMIT 1");
        $query->bindValue(':path', $path);
        $query->execute();
        if (0 < $query->rowCount()) {
            $success = true;
        }
        $query->closeCursor();

        return $success;
    }

    /**
     * Build a MarkupAdminDataTable from page paths data.
     *
     * Utility function to quickly build a table from path data. Just a wrapper
     * to hide the complexity of setting up MarkupAdminDataTable.
     *
     * @param array $headerRow Header row column labels.
     * @param array $tableContent Two-dimensional array with all row data in columns.
     * @return MarkupAdminDataTable Table with input data included, ready to render.
     */
    protected function buildPathsTable($headerRow, $tableContent) {
        /* @var MarkupAdminDataTable $table */
        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->headerRow($headerRow);
        foreach ($tableContent as $content) {
            $table->row($content);
        }
        return $table;
    }

}